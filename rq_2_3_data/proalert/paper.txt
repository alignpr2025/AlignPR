Fig. 3 shows the overview of ProAlert. ProAlert consists of two stages, offline stage and online
stage. For input alerts in both stages, alert embedding parses the variables in alert contents and
generates semantic representations for alerts.
In offline stage, by leveraging system topology and history alerts, propagation pattern mining
aims to mine the propagation patterns of faults between system components. A pattern is a key-
value pair, where the key is a pair of system component types and the value is a set of vectors. The
set of vectors are semantic representations describing faults which frequently propagate between
the pair of specific system component types. In online stage, propagation path validation utilizes the
patterns mined in offline stage to validate propagation paths of faults indicated by newly reported
alerts, thereby accurately summarizing alerts into incidents.
3.1 Alert Embedding
An alert content comprises two parts: variables and constants. Variables capture system metrics
at the time the alert is reported, such as CPU usage and disk availability. Constants describe the
symptom caused by a fault. Alert embedding aims to accurately represent the semantic information
of an alert content. Variables usually do not carry specific semantic information about faults and
may interfere with the accuracy of semantic representation. The remaining text, after removing
variables from the alert content, is defined as a template. Alerts of the same template represent
the same type of fault symptom. Thus, alert embedding first parses alert contents into templates
that consist solely of constants [14, 37]. In this paper, we adopt Drain [14], which is an established
online parser [3, 7, 37], to parse alert contents in both offline and online stages.
Then, each template is embedded into a vector to represent its semantic information. Differ-
ent from existing works [3, 5, 7] that use static word embeddings generated by approaches like
CBOW[23] and FastText [24], we employ a pre-trained text embedding model, BGE [29], to gen-
erate vector representations for each template. BGE is based on BERT [9], which is a popular
transformer-based deep learning model for Natural Language Processing (NLP) pre-training. As
a result, for each input alert, 𝑎𝑖 (1 ≤ 𝑖 ≤ 𝑛), its content, 𝑐𝑖, is parsed into a template and then
embedded as a vector-based semantic representation, 𝑣𝑖.
3.2 Offline Stage
In offline stage, we propose propagation pattern mining for ProAlert to mine the propagation pat-
terns of faults from history alerts and system topology, consisting of two steps:
• Semantics transmission. This step transmits the semantics of alerts that potentially belonging
to the same fault to the edges of paths where the fault might have propagated, based on
system topology.
• Pattern mining. This step clusters the semantics of the edges to obtain the propagation pat-
terns, 𝒫. Each pattern 𝑃 ∈ 𝒫 is a key-value pair, in which the key is a pair of system com-
ponent types and the value is a set of vector-based semantic representations. 𝑃 describes
faults which frequently propagate between a pair of system component types.
3.2.1 Semantics Transmission. Alerts of the same fault usually are reported within short time in-
tervals and the system components reporting these correlated alerts are typically close to each
other [3, 5, 7, 32]. Therefore, for each alert, 𝑎𝑖, in 𝑆 (1 ≤ 𝑖 ≤ 𝑛), semantics transmission first adopts
a time window, [𝑡𝑖 − 𝑤, 𝑡𝑖] to find alerts that are reported within the window. Then, for an alert,
𝑎𝑗 (1 ≤ 𝑗 ≤ 𝑛), within the window, semantics transmission further assesses whether they may be
correlated with 𝑎𝑖 based on system topology.
Due to the hierarchical topology of an online service system discussed in Section 2.1, lower-
layer components serve upper-layer components by providing basic functions, while upper-layer
components depend on and orchestrate lower-layer components to deliver advanced services. Ac-
cordingly, a fault propagates in a cascading manner through system topology [8]. Thus, for 𝑎𝑗 to
be correlated with 𝑎𝑖, there should be a finite length between 𝑜𝑖 and 𝑜𝑗 (not exceeding a maximum
value 𝜏 ) and adheres to one of the following structural constraints:
𝑜𝑖 and 𝑜𝑗 directly or indirectly depend on the same system component in a lower layer.
• 𝑜𝑖 and 𝑜𝑗 directly or indirectly serve the same system component in a higher layer.
• 𝑜𝑖 (𝑜𝑗) directly or indirectly depends on 𝑜𝑗 (𝑜𝑖).
It should be noted that 𝜏 does not represent the length of the longest possible fault propagation
chain. Instead, it denotes the distance between two components where consecutive alerts are trig-
gered during fault propagation. There may be intermediate components between them that do not
report alerts due to limitations in monitoring mechanisms.
Fig. 4 shows three examples of the above structural constraints. By searching system topology,
semantics transmission can obtain all the paths satisfies the above structural constraints. For all
obtained paths, semantics transmission transmits the semantic representations, 𝑣𝑖 and 𝑣𝑗, to the
edges of the paths. Specifically, for an edge 𝑒 in an obtained path, 𝑣𝑖 and 𝑣𝑗 are added to a set, 𝑅𝑒.
It records the semantic representations transmitted to the edge.
3.2.2 Pattern Mining. After semantics transmission, pattern mining mines fault propagation pat-
terns, which describe the types of semantic information related to faults that can be propagated
between two components. For example, a fault propagated between a storage device and a host is
generally related to storage rather than network.
Specifically, pattern mining first aggregates semantic representations on edges formed by
the same component type pair and then clusters the aggregated semantic representations. After
removing outliers, each cluster thus can reveal a fault that frequently propagate between two types
of system components.
For a component type pair, {𝛿𝑜𝑒
, 𝛿𝑜′
𝑒 } (𝑒 =< 𝑜𝑒, 𝑜′
𝑒 >∈ 𝐸), its clustering results are denoted as
𝑉{𝛿𝑜𝑒 ,𝛿𝑜′
𝑒 } = {𝑣1, 𝑣2, ⋯ , 𝑣𝑧}. Each 𝑣𝑘 (1 ≤ 𝑘 ≤ 𝑧) is the centroid of the semantic representations
in a cluster, representing a fault. Thus, the key-value pair, <{𝛿𝑜𝑒
, 𝛿𝑜′
𝑒 }, 𝑉{𝛿𝑜𝑒 ,𝛿𝑜′
𝑒 }>, is a pattern
revealing faults that frequently propagate between the component types, 𝛿𝑜𝑒
and 𝛿𝑜′
.
Existing popular clustering approaches contain partitional approaches like K-Means [21], density-
based approaches like DBSCAN [11], and hierarchical approaches [12, 28]. In this paper, we choose
DBSCAN [11], which is a density-based approach, for ProAlert due to the following reasons. First,
ProAlert has no prior knowledge about the number of clusters, while DBSCAN can infer it based
on data distribution. Second, DBSCAN can work with most distance measures [28]. Third, DB-
SCAN can automatically identify outliers in data and discard them. After the clustering process,
we obtain a set of propagation patterns, denoted as 𝒫, each pattern 𝑃 ∈ 𝒫 is a key-value pair.
Fig. 5 shows a toy example of pattern mining process. Pattern mining first aggregates se-
mantic representations on edges formed by the component type pair, {Server, Host}. Then, pattern
mining clusters them based on semantic similarity. The clustering result, 𝑉{Server,Host}, represent
the propagation pattern of faults between servers and hosts. In the pattern, each of 𝑣1 and 𝑣2
reveals a fault that frequently propagates between the two types of system components in his-
tory. Moreover, outliers that lack sufficient similar semantic representations to form clusters are
regarded as mistransmitted and are discarded.
3.3 Online Stage
In online stage, we propose propagation path validation for ProAlert to summarize alerts. Prop-
agation Path Validation utilizes mined patterns to find the propagation paths of faults indicated
by newly generated alerts. A propagation path is a path between system components associated
with alerts triggered by same fault, revealing the propagation process of the fault. If a propagation
path exists between the system component of a new alert and that of a previous alert, it indicates
that both alerts are triggered by the same fault. Consequently, the new alert is added to the exist-
ing incident containing the previous alert. If no such path exists, the new alert is added to a new
incident.
Specifically, when a new alert, 𝑎𝑖, is reported, ProAlert first examines the time window, [𝑡𝑖−
𝑤, 𝑡𝑖]. If an alert 𝑎𝑗 exists within this time window, ProAlert checks whether there is a path, 𝐿 =
[𝑒1, 𝑒2, ⋯ , 𝑒𝑚] (𝑜′
𝑒𝑘
= 𝑜𝑒𝑘+1 , 1 ≤ 𝑘 ≤ 𝑚−1), connecting their system components, where 𝑜𝑒1
= 𝑜𝑖,
𝑜′
𝑒𝑚
= 𝑜𝑗, and 𝑚 is the length of the path. This path must meet the structural constraints specified
in Section 3.2.1. If these conditions are satisfied, ProAlert then validates whether the path conforms
to the mined patterns.
ProAlert first measures the validity of the fault indicated by 𝑎𝑖 propagating through the path.
For the 𝑘-th edge of the path (1 ≤ 𝑘 ≤ 𝑚), ProAlert computes max cosine similarity between
𝑣𝑖 and the semantic representations in 𝑉{𝛿𝑜𝑒𝑘 ,𝛿𝑜′
}, denoted as 𝑠𝑖
𝑘. In addition, ProAlert adopt the
𝑒𝑘
minimum value of 𝑠𝑖
𝑘 to represent the validity of the fault indicated by 𝑎𝑖 propagating through the
path:
Similarly, ProAlert measures the validity of the fault indicated by 𝑎𝑗 propagating through the
path, denoted as ̂𝑠𝑗. If 𝑎𝑖 and 𝑎𝑗 are reported by the same system component, there is no need to
measure the validity of the path and both values of ̂𝑠𝑖 and ̂𝑠𝑗 equal to the maximum value 1. Then,
for 𝑎𝑖 and 𝑎𝑗, by integrating the validity of the path between their system components with their
semantic similarity, ProAlert measures the correlation score between 𝑎𝑖 and 𝑎𝑗, as defined below:
𝑠𝑐𝑜𝑟𝑒𝑖,𝑗 = 𝛼 ∗ 𝑐𝑜𝑠(𝑣𝑖, 𝑣𝑗) + (1 − 𝛼) ∗ 𝑚𝑖𝑛( ̂𝑠𝑖, ̂𝑠𝑗), (2)
where𝑐𝑜𝑠 computes cosine similarity, 𝛼adjusts ProAlert’s feature attention, If 𝑠𝑐𝑜𝑟𝑒𝑖,𝑗 does not
exceed the threshold, 𝜆, 𝑎𝑖 and 𝑎𝑗 are triggered by different faults.
In addition to measuring the correlation score, ProAlert verifies the dependencies of 𝑜𝑖 and the
system components involved in the previous incident containing 𝑎𝑗. Specifically, ProAlert checks
whether these components depend on the same lower-layer component or serve the same upper-
layer component, either directly or indirectly. If both are satisfied, 𝐿 is a propagation path, indicat-
ing that 𝑎𝑖 and 𝑎𝑗 belong to the same fault. Consequently, 𝑎𝑖 is appended to the previous incident
containing 𝑎𝑗. If multiple alerts within the time window, [𝑡𝑖 − 𝑤, 𝑡𝑖], can be correlated with 𝑎𝑖,
ProAlert chooses the alert with the maximum correlation score. If no alerts can be correlated with
𝑎𝑖, a new incident is created for 𝑎𝑖.